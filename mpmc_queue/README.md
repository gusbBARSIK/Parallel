## Multiple Producer Multiple Consumer Bounded Queue

В этой задаче необходимо реализовать lock-free очередь. Multiple producer multiple consumer означает, что множество потоков могут как добавлять элементы в очередь, так и извлекать. Bounded означает, что размер очереди ограничен.  
Максимальный размер очереди указывается в конструкторе.

Метод `Push` возвращает `false`, если очередь заполнена, иначе вставляет элемент и возвращает `true`.  
Метод `Pop` возвращает `std::nullopt`, если очередь пуста, иначе извлекает и возвращает элемент.

Алгоритм:
1. Создаем массив нужного размера. Для простоты - размер очереди может быть только степенью двойки - 2, 4, 8 и т.д.
2. Каждый элемент массива состоит из объекта типа T и атомарной беззнакового числа - поколения.
3. Изначально поколение равено индексу элемента в массиве.
4. Также хранится 2 индекса - на начало (`head`) и конец (`tail`) очереди. Эти индексы никогда не уменьшаются, а для получения индекса в массиве необходимо взять остаток от деления на `size` (в нашем случае можно взять побитовое И с `size - 1`, так как размер - степень двойки).
5. При вставке элемента, если в очереди есть место, увеличиваем индекс `head` на единицу, тем самым резервируя место. После копирования элемента, увеличиваем поколение на единицу, показывая тем самым, что мы записали элемент. Заметьте, что записывать элемент можно только в том случае, если поколение равно значению `head`, что означает, что элемент оттуда уже забран (или его не было изначально).
6. При удалении элемента, если очередь не пуста,  увеличиваем индекс `tail` на единицу, тем самым резервируя элемент. После копирования элемента себе, увеличиваем поколение на `size - 1`, показывая тем самым, что мы забрали элемент и освободили место. Заметьте, что забирать элемент можно только в том случае, если поколение равно значению `tail + 1`, что означает, что элемент туда был записан.

Можно изначально записывать в поколение нули, а дальше увеличивать их только на единицу и при добавлении элемента, и при его удалении, однако в таком случае проверки становятся сложнее - в приведенном алгоритме достаточно проверить что поколение равно `head` при добавлении или `tail + 1` при удалении.  
Постоянное увеличение индексов начала и конца очереди необходимы, чтобы избежать [ABA-проблемы](https://en.wikipedia.org/wiki/ABA_problem).

---

В этой задаче также нужно использовать CAS операции. Запрещается использовать блокировки.
